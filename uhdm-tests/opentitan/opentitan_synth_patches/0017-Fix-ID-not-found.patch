From a1d466d26f3ccd4b975d061d1b7f51fd9798db4d Mon Sep 17 00:00:00 2001
From: Kamil Rakoczy <krakoczy@antmicro.com>
Date: Fri, 17 Mar 2023 17:16:02 +0100
Subject: [PATCH 17/18] Fix ID not found

Signed-off-by: Kamil Rakoczy <krakoczy@antmicro.com>
---
 hw/ip/lc_ctrl/rtl/lc_ctrl_pkg.sv | 14 +++++++-------
 hw/ip/prim/rtl/prim_mubi_pkg.sv  | 10 +++++-----
 2 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/hw/ip/lc_ctrl/rtl/lc_ctrl_pkg.sv b/hw/ip/lc_ctrl/rtl/lc_ctrl_pkg.sv
index 681c4f0cf..4d55faad2 100644
--- a/hw/ip/lc_ctrl/rtl/lc_ctrl_pkg.sv
+++ b/hw/ip/lc_ctrl/rtl/lc_ctrl_pkg.sv
@@ -79,17 +79,17 @@ package lc_ctrl_pkg;
   // Since the false value is always complement of the true value,
   // this mechanism will also work for the other polarity.
   function automatic prim_mubi_pkg::mubi4_t lc_to_mubi4(lc_tx_t val);
-    return prim_mubi_pkg::mubi4_t'(val ^ (On ^ prim_mubi_pkg::MuBi4True));
+    return prim_mubi_pkg::mubi4_t'(val ^ (lc_ctrl_pkg::On ^ prim_mubi_pkg::MuBi4True));
   endfunction : lc_to_mubi4
 
   function automatic lc_tx_t mubi4_to_lc(prim_mubi_pkg::mubi4_t val);
-    return lc_tx_t'(val ^ (prim_mubi_pkg::MuBi4True ^ On));
+    return lc_tx_t'(val ^ (prim_mubi_pkg::MuBi4True ^ lc_ctrl_pkg::On));
   endfunction : mubi4_to_lc
 
   // same function as above, but for an input that is MuBi4True, return Off
   // for an input that is MuBi4False, return On
   function automatic lc_tx_t mubi4_to_lc_inv(prim_mubi_pkg::mubi4_t val);
-    return lc_tx_t'(val ^ (prim_mubi_pkg::MuBi4True ^ Off));
+    return lc_tx_t'(val ^ (prim_mubi_pkg::MuBi4True ^ lc_ctrl_pkg::Off));
   endfunction : mubi4_to_lc_inv
 
   // Test whether the value is supplied is one of the valid enumerations
@@ -99,14 +99,14 @@ package lc_ctrl_pkg;
 
   // Convert a 1 input value to a lc_tx output
   function automatic lc_tx_t lc_tx_bool_to_lc_tx(logic val);
-    return (val ? On : Off);
+    return (val ? lc_ctrl_pkg::On : lc_ctrl_pkg::Off);
   endfunction : lc_tx_bool_to_lc_tx
 
   // Test whether the multibit value signals an "enabled" condition.
   // The strict version of this function requires
   // the multibit value to equal True.
   function automatic logic lc_tx_test_true_strict(lc_tx_t val);
-    return On == val;
+    return lc_ctrl_pkg::On == val;
   endfunction : lc_tx_test_true_strict
 
   // Test whether the multibit value signals a "disabled" condition.
@@ -127,7 +127,7 @@ package lc_ctrl_pkg;
   // The loose version of this function interprets all
   // values other than True as "disabled".
   function automatic logic lc_tx_test_false_loose(lc_tx_t val);
-    return On != val;
+    return lc_ctrl_pkg::On != val;
   endfunction : lc_tx_test_false_loose
 
 
@@ -203,7 +203,7 @@ package lc_ctrl_pkg;
   // This treats "True" as logical 1, and all other values are
   // treated as 0.
   function automatic lc_tx_t lc_tx_and_hi(lc_tx_t a, lc_tx_t b);
-    return lc_tx_and(a, b, On);
+    return lc_tx_and(a, b, lc_ctrl_pkg::On);
   endfunction : lc_tx_and_hi
 
   // Performs a logical OR operation between two multibit values.
diff --git a/hw/ip/prim/rtl/prim_mubi_pkg.sv b/hw/ip/prim/rtl/prim_mubi_pkg.sv
index b5d7c1bbf..b74379902 100644
--- a/hw/ip/prim/rtl/prim_mubi_pkg.sv
+++ b/hw/ip/prim/rtl/prim_mubi_pkg.sv
@@ -29,19 +29,19 @@ package prim_mubi_pkg;
 
   // Test whether the value is supplied is one of the valid enumerations
   function automatic logic mubi4_test_invalid(mubi4_t val);
-    return ~(val inside {MuBi4True, MuBi4False});
+    return ~(val inside {prim_mubi_pkg::MuBi4True, prim_mubi_pkg::MuBi4False});
   endfunction : mubi4_test_invalid
 
   // Convert a 1 input value to a mubi output
   function automatic mubi4_t mubi4_bool_to_mubi(logic val);
-    return (val ? MuBi4True : MuBi4False);
+    return (val ? prim_mubi_pkg::MuBi4True : prim_mubi_pkg::MuBi4False);
   endfunction : mubi4_bool_to_mubi
 
   // Test whether the multibit value signals an "enabled" condition.
   // The strict version of this function requires
   // the multibit value to equal True.
   function automatic logic mubi4_test_true_strict(mubi4_t val);
-    return MuBi4True == val;
+    return prim_mubi_pkg::MuBi4True == val;
   endfunction : mubi4_test_true_strict
 
   // Test whether the multibit value signals a "disabled" condition.
@@ -55,7 +55,7 @@ package prim_mubi_pkg;
   // The loose version of this function interprets all
   // values other than False as "enabled".
   function automatic logic mubi4_test_true_loose(mubi4_t val);
-    return MuBi4False != val;
+    return prim_mubi_pkg::MuBi4False != val;
   endfunction : mubi4_test_true_loose
 
   // Test whether the multibit value signals a "disabled" condition.
@@ -173,7 +173,7 @@ package prim_mubi_pkg;
   // The strict version of this function requires
   // the multibit value to equal True.
   function automatic logic mubi8_test_true_strict(mubi8_t val);
-    return MuBi8True == val;
+    return prim_mubi_pkg::MuBi8True == val;
   endfunction : mubi8_test_true_strict
 
   // Test whether the multibit value signals a "disabled" condition.
-- 
2.39.0

